#!/usr/bin/env bash

# @describe Scan target with trufflehog and convert results to CSV
# @meta require-tools trufflehog,jq
# @arg target=. Target file or directory to scan
# @option -r --results=verified <TYPE> Results type(s) [verified|unverified|unknown], comma-separated for multiple
# @option -o --output <NAME> Base name for output files (auto-detected if not provided)
# @flag -j --json-only Output only JSONL, skip CSV conversion
# @flag -q --quiet Suppress progress output
# @flag -v --verbose Enable verbose output

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Scan target with trufflehog and convert results to CSV

USAGE: trfl [OPTIONS] [TARGET]

ARGS:
  [TARGET]  Target file or directory to scan [default: .]

OPTIONS:
  -r, --results <TYPE>  Results type(s) [verified|unverified|unknown], comma-separated for multiple [default: verified]
  -o, --output <NAME>   Base name for output files (auto-detected if not provided)
  -j, --json-only       Output only JSONL, skip CSV conversion
  -q, --quiet           Suppress progress output
  -v, --verbose         Enable verbose output
  -h, --help            Print help
  -V, --version         Print version
EOF
    exit
}

_argc_version() {
    echo trfl 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --results | -r)
            _argc_take_args "--results <TYPE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_results:-}" ]]; then
                argc_results="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--results\` cannot be used multiple times"
            fi
            ;;
        --output | -o)
            _argc_take_args "--output <NAME>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_output:-}" ]]; then
                argc_output="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--output\` cannot be used multiple times"
            fi
            ;;
        --json-only | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json-only\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json_only:-}" ]]; then
                _argc_die "error: the argument \`--json-only\` cannot be used multiple times"
            else
                argc_json_only=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        --verbose | -v)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--verbose\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_verbose:-}" ]]; then
                _argc_die "error: the argument \`--verbose\` cannot be used multiple times"
            else
                argc_verbose=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(trufflehog jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=main
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_target="${argc__positionals[values_index]}"
        else
            argc_target=.
            argc__positionals+=("$argc_target")
        fi
        if [[ -z "${argc_results:-}" ]]; then
            argc_results=verified
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

# Setup colors
setup_colors() {
  if [[ "$argc_quiet" == 1 ]] || [[ -z "$TERM" ]] || [[ "$TERM" == "dumb" ]]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) red=$(tput setaf 1)
  fi
}
setup_colors

log() { [[ -z "$argc_quiet" ]] && printf "%s\n" "$*" >&2; }
log_verbose() { [[ -n "$argc_verbose" ]] && printf "${blue}::${reset} %s\n" "$*" >&2; }
die() { printf "${red}Error:${reset} %s\n" "$*" >&2; exit 1; }

# Check if file is an archive type
is_archive() {
  local file="$1"
  case "${file,,}" in
    *.zip|*.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.gz|*.bz2|*.xz|*.7z|*.rar) return 0 ;;
    *) return 1 ;;
  esac
}

# Count files in archive
count_archive_files() {
  local file="$1"
  case "${file,,}" in
    *.zip) unzip -l "$file" 2>/dev/null | tail -1 | awk '{print $2}' ;;
    *.tar) tar -tf "$file" 2>/dev/null | wc -l ;;
    *.tar.gz|*.tgz) tar -tzf "$file" 2>/dev/null | wc -l ;;
    *.tar.bz2|*.tbz2) tar -tjf "$file" 2>/dev/null | wc -l ;;
    *.tar.xz|*.txz) tar -tJf "$file" 2>/dev/null | wc -l ;;
    *.7z) 7z l "$file" 2>/dev/null | grep -c "^[0-9]" ;;
    *) echo 1 ;;  # Fallback for unknown archive types
  esac
}

# Validate results type
validate_results_type() {
  local valid_types=("verified" "unverified" "unknown")
  local result_type
  local input="${argc_results%$'\n'}"

  while IFS= read -r -d',' result_type || [[ -n "$result_type" ]]; do
    result_type="${result_type%$'\n'}"
    result_type="${result_type## }"
    result_type="${result_type%% }"
    [[ -z "$result_type" ]] && continue
    if [[ ! " ${valid_types[*]} " =~ " ${result_type} " ]]; then
      die "Invalid results type: $result_type (valid: verified, unverified, unknown)"
    fi
  done <<< "$input"
}

# Determine base name for output files
get_base_name() {
  if [[ -n "$argc_output" ]]; then
    echo "$argc_output"
  elif [[ -f "$argc_target" ]]; then
    local base
    base=$(basename "$argc_target")
    echo "${base%.*}"
  elif [[ -d "$argc_target" ]]; then
    basename "$argc_target"
  else
    echo "results"
  fi
}

# Validate target exists
validate_target() {
  [[ -e "$argc_target" ]] || die "Target does not exist: $argc_target"
}

# Draw progress bar
draw_progress() {
  local current="$1" total="$2" label="$3" width=30
  [[ $total -eq 0 ]] && total=1
  [[ $current -gt $total ]] && current=$total
  
  local percent=$((current * 100 / total))
  local filled=$((current * width / total))
  local empty=$((width - filled))
  local bar=""
  
  for ((i=0; i<filled; i++)); do bar+="█"; done
  for ((i=0; i<empty; i++)); do bar+="░"; done
  
  printf "\r${cyan}[${green}%s${cyan}]${reset} %3d%% (%d/%d %s)" \
    "$bar" "$percent" "$current" "$total" "$label" >&2
}

# Draw spinner with message
draw_spinner() {
  local frame="$1" label="$2"
  local frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
  local spinner="${frames[$((frame % ${#frames[@]}))]}"
  printf "\r${cyan}%s${reset} %s" "$spinner" "$label" >&2
}

# Draw final result for spinner mode
draw_spinner_done() {
  local chunks="$1"
  printf "\r${green}✓${reset} Scanned %d chunks\n" "$chunks" >&2
}

# Estimate chunks for a single file (trufflehog uses ~12KB chunks)
estimate_file_chunks() {
  local file="$1"
  local size
  size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
  local chunks=$(( (size + 12000 - 1) / 12000 ))  # Round up
  [[ $chunks -lt 1 ]] && chunks=1
  echo "$chunks"
}

# Count total items for progress
count_items() {
  if [[ -f "$argc_target" ]]; then
    if is_archive "$argc_target"; then
      count_archive_files "$argc_target"
    else
      estimate_file_chunks "$argc_target"  # Estimate chunks based on file size
    fi
  else
    find "$argc_target" -type f 2>/dev/null | wc -l
  fi
}

# Run trufflehog scan with progress
run_scan() {
  local jsonl_file="$1"
  
  log_verbose "Target: $argc_target"
  log_verbose "Results type(s): $argc_results"
  log_verbose "Output: $jsonl_file"
  
  local total_items item_type is_single_file=false
  total_items=$(count_items)
  
  if [[ -f "$argc_target" ]] && ! is_archive "$argc_target"; then
    is_single_file=true
    item_type="chunks"
  else
    item_type="files"
  fi
  
  if [[ -z "$argc_quiet" ]]; then
    > "$jsonl_file"
    
    # Use named pipe to process stderr while capturing stdout to file
    # Log levels: 0=info, 3=scanning file, 4=opened file (archives)
    local fifo log_level
    fifo=$(mktemp -u)
    mkfifo "$fifo"
    
    if [[ -f "$argc_target" ]]; then
      if is_archive "$argc_target"; then
        log_level=4  # Archives: "Opened file successfully" messages
      else
        log_level=0  # Single files: "finished scanning" message with chunks count
      fi
    else
      log_level=3    # Directories: "scanning file" messages
    fi
    
    if [[ "$is_single_file" == true ]]; then
      # Single file: use spinner since trufflehog doesn't provide incremental progress
      local spinner_frame=0 actual_chunks=0
      
      # Start spinner in background
      {
        while true; do
          draw_spinner "$spinner_frame" "Scanning file..."
          ((spinner_frame++))
          sleep 0.1
        done
      } &
      local spinner_pid=$!
      
      # Capture stderr to extract chunk count
      local stderr_file
      stderr_file=$(mktemp)
      
      trufflehog filesystem "$argc_target" --results "$argc_results" -j --log-level=0 \
        > "$jsonl_file" 2>"$stderr_file"
      
      # Stop spinner
      kill "$spinner_pid" 2>/dev/null
      wait "$spinner_pid" 2>/dev/null || true
      
      # Extract chunk count from stderr
      actual_chunks=$(grep '"finished scanning"' "$stderr_file" | jq -r '.chunks // 0' 2>/dev/null)
      rm -f "$stderr_file"
      
      [[ -z "$actual_chunks" || "$actual_chunks" == "0" ]] && actual_chunks=1
      draw_spinner_done "$actual_chunks"
    else
      # Directory/archive: use progress bar with incremental updates
      log "${cyan}Scanning...${reset}"
      draw_progress 0 "$total_items" "$item_type"
      
      # Process stderr in background for progress updates
      {
        local processed=0
        declare -A seen_files
        while IFS= read -r line; do
          # For archives: track "Opened file successfully" messages (log-level 4)
          if [[ "$line" == *'"msg":"Opened file successfully"'* ]]; then
            local filename
            filename=$(echo "$line" | jq -r '.filename // empty' 2>/dev/null)
            if [[ -n "$filename" && -z "${seen_files[$filename]:-}" ]]; then
              seen_files["$filename"]=1
              ((processed++))
              draw_progress "$processed" "$total_items" "$item_type"
            fi
          # For directories: track "scanning file" messages (log-level 3)
          elif [[ "$line" == *'"msg":"scanning file"'* ]]; then
            local scanned_path
            scanned_path=$(echo "$line" | jq -r '.path // empty' 2>/dev/null)
            if [[ -n "$scanned_path" && -z "${seen_files[$scanned_path]:-}" ]]; then
              seen_files["$scanned_path"]=1
              ((processed++))
              draw_progress "$processed" "$total_items" "$item_type"
            fi
          fi
        done < "$fifo"
      } &
      local progress_pid=$!
      
      # Run trufflehog: stdout to jsonl file, stderr to fifo for progress
      trufflehog filesystem "$argc_target" --results "$argc_results" -j --log-level="$log_level" \
        > "$jsonl_file" 2>"$fifo"
      
      wait "$progress_pid" 2>/dev/null || true
      rm -f "$fifo"
      
      # Show 100% at end
      draw_progress "$total_items" "$total_items" "$item_type"
      printf "\n" >&2
    fi
  else
    if ! trufflehog filesystem "$argc_target" --results "$argc_results" -j 2>/dev/null > "$jsonl_file"; then
      die "Trufflehog scan failed"
    fi
  fi
  
  local count
  count=$(wc -l < "$jsonl_file")
  log "${green}Found ${bold}${count}${reset}${green} results${reset}"
}

# Convert JSONL to CSV
convert_to_csv() {
  local jsonl_file="$1"
  local csv_file="$2"
  
  log_verbose "Converting to CSV: $csv_file"
  
  # Print header once, then process each line
  {
    echo '"Verified","DetectorName","Raw","RawV2","ExtraData"'
    jq -r '[
      .Verified,
      .DetectorName,
      (.Raw | gsub("\n"; " ")),
      (.RawV2 // "" | gsub("\n"; " ")),
      (.ExtraData | if . == null then "" else (tostring | gsub("\n"; " ")) end)
    ] | @csv' "$jsonl_file"
  } | awk '!seen[$0]++' > "$csv_file"
  
  if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    die "CSV conversion failed"
  fi
}

# Main execution
main() {
  validate_results_type
  validate_target
  
  local base_name jsonl_file csv_file
  base_name=$(get_base_name)
  jsonl_file="${base_name}.jsonl"
  csv_file="${base_name}.csv"
  
  run_scan "$jsonl_file"
  
  if [[ -z "$argc_json_only" ]]; then
    convert_to_csv "$jsonl_file" "$csv_file"
    log "\n${green}Done:${reset} ${cyan}$jsonl_file${reset}, ${cyan}$csv_file${reset}"
  else
    log "\n${green}Done:${reset} ${cyan}$jsonl_file${reset}"
  fi
}

main
